#include "main.h"

namespace {
const int many = 50;

// How many clauses a term will expand into, for the purpose of deciding when subformulas need to be renamed. The answer could
// exceed the range of a fixed-size integer, but then we don't actually need the number, we only need to know whether it went over
// the threshold.
int ncs(bool pol, term a);

int ncsMul(bool pol, term a) {
	int n = 1;
	// TODO: use foreach
	for (size_t i = 1; i != a.size(); ++i) {
		n *= ncs(pol, a[i]);
		if (n >= many) return many;
	}
	return n;
}

int ncsAdd(bool pol, term a) {
	int n = 0;
	for (size_t i = 1; i != a.size(); ++i) {
		n += ncs(pol, a[i]);
		if (n >= many) return many;
	}
	return n;
}

int ncs(bool pol, term a) {
	// NO_SORT
	switch (tag(a)) {
	case tag::All:
	case tag::Exists:
		return ncs(pol, a[1]);

	case tag::Not:
		return ncs(!pol, a[1]);

	case tag::Or:
		return pol ? ncsMul(pol, a) : ncsAdd(pol, a);
	case tag::And:
		return pol ? ncsAdd(pol, a) : ncsMul(pol, a);

	case tag::Eqv:
	{
		auto x = a[1];
		auto y = a[2];

		// Recur twice into each argument. This would cause a problem of exponential blowup in the time taken to calculate the
		// number of clauses that would be generated by nested equivalences. We solve this problem by returning early if the number
		// is becoming large.
		int n;
		if (pol) {
			n = ncs(0, x) * ncs(1, y);
			if (n >= many) return many;
			n += ncs(1, x) * ncs(0, y);
		} else {
			n = ncs(0, x) * ncs(0, y);
			if (n >= many) return many;
			n += ncs(1, x) * ncs(1, y);
		}
		return min(n, many);
	}
	}
	return 1;
}

// The function to calculate the number of clauses generated by a formula in a positive or negative context, returns a
// mathematically defined result (up to a ceiling). However, when it comes to actually trying to rename formulas, we may be dealing
// with both positive and negative contexts. In particular, this may happen in nested equivalences, where the total number of
// formulas cannot be calculated without the full context, but would in any case be unreasonably large, so it is neither feasible
// nor necessary to calculate the number. What we actually need to do is make a heuristic decision. To that end, if we have a
// context that is both positive and negative, we add the two values for the number of clauses; this doesn't have a clear
// mathematical justification, but seems as reasonable as anything else, and simple enough that there are hopefully few ways it can
// go wrong.
int ncsApprox(int pol, term a) {
	int n = 0;
	if (pol >= 0) n += ncs(1, a);
	if (pol <= 0) n += ncs(0, a);
	return n;
}

struct doing {
	// SORT
	set<clause>& cs;
	set<term> defs;
	ProofCnf& proofCnf;
	size_t vars = 0;
	///

	// Skolem functions replace existentially quantified variables, also formulas that are renamed to avoid exponential expansion.
	term skolem(type rty, const set<term>& args) {
		vec<term> v(1, gensym(ftype(rty, args)));
		// TODO: single call instead of loop?
		for (auto b: args) v.push_back(b);
		return term(v);
	}

	// Rename formulas to avoid exponential expansion. It's tricky to do this while in the middle of doing other things, easier to
	// be sure of the logic if it's done as a separate pass first.
	term rename(int pol, term a) {
		auto b = skolem(type(a), freeVars(a));
		// NO_SORT
		switch (pol) {
		case 1:
			// If this formula is only being used with positive polarity, the new name only needs to imply the original formula.
			a = imp(b, a);
			break;
		case -1:
			// And the reverse for negative polarity.
			a = imp(a, b);
			break;
		case 0:
			// In the general case, full equivalence is needed; the new name implies and is implied by the original formula.
			a = term(tag::And, imp(b, a), imp(a, b));
			break;
		default:
			unreachable;
		}
		defs.add(quantify(a));
		return b;
	}

	// Maybe rename some of the arguments to an OR-over-AND (taking polarity into account), where the number of clauses generated
	// would be the product of the arguments.
	void maybeRename(int pol, vec<term>& v) {
		// Sorting the arguments doesn't change the meaning of the formula, because AND and OR are commutative. The effect is that
		// if only some of them are to be renamed, we will leave the simple ones alone and end up renaming the complicated ones,
		// which is probably what we want.
		sort(v.begin() + 1, v.end(), [=](term a, term b) { return ncsApprox(pol, a) < ncsApprox(pol, b); });
		int n = 1;
		for (size_t i = 1; i != v.size(); ++i) {
			auto m = ncsApprox(pol, v[i]);
			if (n * m < many) n *= m;
			else
				v[i] = rename(pol, v[i]);
		}
	}

	// Given a formula, and whether it is used for positive polarity, negative or both (i.e. under an equivalence), maybe rename
	// some of its subformulas. If a subformula occurs many times (whether under the same formula, or different ones), it is
	// considered in isolation each time, so that each occurrence could end up with a different name. In principle, it would be more
	// efficient to rename on a global basis, but in practice, nontrivial subformulas are rarely duplicated (e.g. less than 1% of
	// the nontrivial formulas in the TPTP), so this is probably not worth doing.
	term maybeRename(int pol, term a) {
		vec<term> v(1, a[0]);
		// NO_SORT
		switch (tag(a)) {
		case tag::All:
		case tag::Exists:
			v.push_back(maybeRename(pol, a[1]));
			for (size_t i = 2; i != a.size(); ++i) v.push_back(a[i]);
			break;

		case tag::Not:
			return term(tag::Not, maybeRename(-pol, a[1]));

		case tag::Or:
			for (size_t i = 1; i != a.size(); ++i) v.push_back(maybeRename(pol, a[i]));

			// If this formula will be used with positive polarity (including the case where it will be used both ways), we are
			// looking at OR over possible ANDs, which would produce exponential expansion at the distribution stage, so may need to
			// rename some of the arguments.
			if (pol >= 0) maybeRename(pol, v);
			break;
		case tag::And:
			for (size_t i = 1; i != a.size(); ++i) v.push_back(maybeRename(pol, a[i]));

			// NOT-AND yields OR, so mirror the OR case.
			if (pol <= 0) maybeRename(pol, v);
			break;

		case tag::Eqv:
		{
			auto x = maybeRename(0, a[1]);
			auto y = maybeRename(0, a[2]);
			if (ncsApprox(0, x) >= many) x = rename(0, x);
			if (ncsApprox(0, y) >= many) y = rename(0, y);
			return term(tag::Eqv, x, y);
		}

		default:
			return a;
		}
		return term(v);
	}

	// For-all doesn't need much work to convert. Clauses contain variables with implied for-all. The tricky part is that quantifier
	// binds variables to local scope, so the same variable name used in two for-all's corresponds to two different logical
	// variables. So we rename each quantified variable to a new variable of the same type.
	map<term, term> all(map<term, term> m, term a) {
		for (size_t i = 2; i != a.size(); ++i) {
			auto x = a[i];
			assert(tag(x) == tag::Var);
			auto y = var(vars++, type(x));
			m.add(x, y);
		}
		return m;
	}

	// Each existentially quantified variable is replaced with a Skolem function whose parameters are all the surrounding
	// universally quantified variables.
	map<term, term> exists(map<term, term> m, term a) {
		// Get the surrounding universally quantified variables that will be arguments to the Skolem functions.
		set<term> args;
		for (auto& kv: m)
			if (tag(kv.second) == tag::Var) args.add(kv.second);

		// Make a replacement for each existentially quantified variable.
		for (size_t i = 2; i != a.size(); ++i) {
			auto x = a[i];
			assert(tag(x) == tag::Var);
			auto y = skolem(type(x), args);
			m.add(x, y);
		}
		return m;
	}

	// Negation normal form consists of several transformations that are as easy to do at the same time: Move NOTs inward to the
	// literal layer, flipping things around on the way, while simultaneously resolving quantifiers.
	term nnf(map<term, term> m, bool pol, term a) {
		vec<term> v(1, a[0]);
		// NO_SORT
		switch (tag(a)) {
			// Boolean constants and operators can be inverted by downward-sinking NOTs.
		case tag::False:
			return tbool(!pol);
		case tag::True:
			return tbool(pol);

		case tag::Not:
			return nnf(m, !pol, a[1]);

		case tag::Or:
			if (!pol) v[0] = term(tag::And);
			for (size_t i = 1; i != a.size(); ++i) v.push_back(nnf(m, pol, a[i]));
			return term(v);
		case tag::And:
			if (!pol) v[0] = term(tag::Or);
			for (size_t i = 1; i != a.size(); ++i) v.push_back(nnf(m, pol, a[i]));
			return term(v);

			// Variables are mapped to new variables or Skolem functions.
		case tag::Var:
			return m.at(a);

			// According to whether they are bound by universal or existential quantifiers.
		case tag::All:
			m = pol ? all(m, a) : exists(m, a);
			return nnf(m, pol, a[1]);
		case tag::Exists:
			m = pol ? exists(m, a) : all(m, a);
			return nnf(m, pol, a[1]);

			// Equivalence is the most difficult operator to deal with.
		case tag::Eqv:
		{
			auto x = a[1];
			auto y = a[2];
			auto x0 = nnf(m, 0, x);
			auto x1 = nnf(m, 1, x);
			auto y0 = nnf(m, 0, y);
			auto y1 = nnf(m, 1, y);
			return pol ? term(tag::And, term(tag::Or, x0, y1), term(tag::Or, x1, y0))
					   : term(tag::And, term(tag::Or, x0, y0), term(tag::Or, x1, y1));
		}
		}
		for (size_t i = 1; i != a.size(); ++i) v.push_back(nnf(m, 1, a[i]));
		a = term(v);
		return pol ? a : term(tag::Not, a);
	}

	// Distribute OR down into AND, completing the layering of the operators for CNF. This is the second place where exponential
	// expansion would occur, had selected formulas not already been renamed.
	term distribute(term a) {
		vec<term> v(1, term(tag::And));
		switch (tag(a)) {
		case tag::And:
			for (size_t i = 1; i != a.size(); ++i) v.push_back(distribute(a[i]));
			break;
		case tag::Or:
		{
			// Arguments can be taken without loss of generality as ANDs.
			vec<vec<term>> ands;
			for (size_t i = 1; i != a.size(); ++i) {
				// Recur.
				auto b = distribute(a[i]);

				// And make a flat layer of ANDs.
				ands.push_back(flatten(tag::And, b));
			}

			// OR distributes over AND by Cartesian product.
			// TODO: can this be done by reference?
			for (auto u: cartProduct(ands)) {
				u.insert(u.begin(), term(tag::Or));
				v.push_back(term(u));
			}
			break;
		}
		default:
			return a;
		}
		return term(v);
	}

	// Convert a suitably rearranged term into actual clauses.
	void clauseTerm(term a, vec<term>& neg, vec<term>& pos) {
		switch (tag(a)) {
		case tag::All:
		case tag::And:
		case tag::Eqv:
		case tag::Exists:
			unreachable;
		case tag::Not:
			neg.push_back(a[1]);
			return;
		case tag::Or:
			for (size_t i = 1; i != a.size(); ++i) clauseTerm(a[i], neg, pos);
			return;
		}
		pos.push_back(a);
	}

	clause clauseTerm(term a) {
		vec<term> neg;
		vec<term> pos;
		clauseTerm(a, neg, pos);
		auto c = make_pair(neg, pos);
		c = simplify(map<term, term>(), c);
		c = uniq(c);
		return c;
	}

	// And record the clauses.
	void csTerm(term from, term a) {
		for (auto& b: flatten(tag::And, a)) {
			auto c = clauseTerm(b);
			if (c == truec) continue;
			proofCnf.add(c, from);
			cs.add(c);
		}
	}

	// Top level.
	doing(const set<term>& initialFormulas, ProofCnf& proofCnf, set<clause>& cs): proofCnf(proofCnf), cs(cs) {
		// First run each input formula through the full process: Rename subformulas where necessary to avoid exponential expansion,
		// then convert to negation normal form, distribute OR into AND, and convert to clauses.
		for (auto a: initialFormulas) {
			auto from = a;
			a = maybeRename(1, a);
			vars = 0;
			a = nnf(map<term, term>(), 1, a);
			a = distribute(a);
			csTerm(from, a);
		}

		// Then convert all the definitions created by the renaming process. That process works by bottom-up recursion, which means
		// each renamed subformula is simple, so there is no need to put the definitions through the renaming process again; they
		// just need to go through the rest of the conversion steps.
		for (auto a: defs) {
			auto from = a;
			vars = 0;
			a = nnf(map<term, term>(), 1, a);
			a = distribute(a);
			csTerm(from, a);
		}
	}
};
} // namespace

void cnf(const set<term>& initialFormulas, ProofCnf& proofCnf, set<clause>& cs) {
	doing _(initialFormulas, proofCnf, cs);
}
